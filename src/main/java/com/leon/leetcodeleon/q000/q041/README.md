```
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例 1:

输入: [1,2,0]
输出: 3
示例 2:

输入: [3,4,-1,1]
输出: 2
示例 3:

输入: [7,8,9,11,12]
输出: 1
说明:

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/first-missing-positive
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```


思路全无，看了遍官方解法，有一个初步了解，核心思想就是：最终结果，小于等于 数组的大小，那么就可以把数组本身作为 hash 表，下面是官方解法的步骤

* 检查 1 是否存在于数组中。如果没有，则已经完成，1 即为答案。
* 如果 nums = [1]，答案即为 2 。
* 将负数，零，和大于 n 的数替换为 1 。
* 遍历数组。当读到数字 a 时，替换第 a 个元素的符号。
 注意重复元素：只能改变一次符号。由于没有下标 n ，使用下标 0 的元素保存是否存在数字 n。
* 再次遍历数组。返回第一个正数元素的下标。
* 如果 nums[0] > 0，则返回 n 。
* 如果之前的步骤中没有发现 nums 中有正数元素，则返回n + 1。

作者：LeetCode
链接：https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
